#
# Copyright (c) 2024 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

#
# DFU Extra Image Extension System
#
# This file provides functions for adding extra images to DFU packages.
# It supports both multi-image binaries and ZIP packages, allowing applications 
# to extend the built-in DFU functionality with additional extra firmware images.
#


#
# Add a extra binary to DFU packages (both multi-image binary and ZIP)
#
# Usage:
#   dfu_add_extra_binary(
#     BINARY_ID <id>
#     BINARY_PATH <path>
#     [ZIP_NAME <name>]
#     [ZIP_SLOT_ID <number>]
#     [DEPENDS <target1> [<target2> ...]]
#   )
#
# Parameters:
#   BINARY_ID             - Numeric identifier for the extra binary (signed integer)
#                          Used in multi-image packages. Should be unique.
#                          Built-in IDs: -2,-1 (MCUboot), 0 (app), 1 (net), 2 (wifi_fw)
#   BINARY_PATH           - Path to the binary file to include in the package
#                          Can be signed (*.signed.bin) or unsigned (*.bin) binary
#   ZIP_NAME              - Optional name for the binary in ZIP packages (defaults to basename of BINARY_PATH)
#   ZIP_SLOT_ID           - Optional slot ID for ZIP packages (defaults to BINARY_ID)
#                          For mcumgr/BLE compatibility, should be 0-3
#   DEPENDS               - Optional list of CMake targets that must be built before
#                          this extra binary is available
#
function(dfu_add_extra_binary)
    cmake_parse_arguments(CUSTOM "" "BINARY_ID;BINARY_PATH;ZIP_NAME;ZIP_SLOT_ID" "DEPENDS" ${ARGN})

    if(NOT DEFINED CUSTOM_BINARY_ID)
        message(FATAL_ERROR "dfu_add_extra_binary: BINARY_ID is required")
    endif()

    if(NOT DEFINED CUSTOM_BINARY_PATH)
        message(FATAL_ERROR "dfu_add_extra_binary: BINARY_PATH is required")
    endif()

    # Validate BINARY_ID is a number
    if(NOT CUSTOM_BINARY_ID MATCHES "^-?[0-9]+$")
        message(FATAL_ERROR "dfu_add_extra_binary: BINARY_ID must be a signed integer, got: ${CUSTOM_BINARY_ID}")
    endif()


    # Set defaults for optional parameters
    if(NOT DEFINED CUSTOM_ZIP_NAME)
        get_filename_component(CUSTOM_ZIP_NAME ${CUSTOM_BINARY_PATH} NAME)
    endif()

    if(NOT DEFINED CUSTOM_ZIP_SLOT_ID)
        set(CUSTOM_ZIP_SLOT_ID ${CUSTOM_BINARY_ID})
    endif()

    # Prepare target list for dependencies
    set(target_list "${CUSTOM_DEPENDS}")

    # Save to args file for cross-phase communication (following NCS pattern like dfu_multi_image.cmake)
    set(dfu_args_file "${CMAKE_BINARY_DIR}/dfu_extra_binaries.args")
    
    # Initialize the cache file with header on first call
    if(NOT EXISTS "${dfu_args_file}")
        file(WRITE "${dfu_args_file}" "# DFU Extra Binaries Cache\n# This file is automatically generated - do not edit manually\n")
    endif()
    
    # Build argument lines for this binary
    set(args_content "")
    string(APPEND args_content "MULTI_IMAGE_ID\n${CUSTOM_BINARY_ID}\n")
    string(APPEND args_content "MULTI_IMAGE_PATH\n${CUSTOM_BINARY_PATH}\n") 
    string(APPEND args_content "MULTI_IMAGE_TARGET\n${target_list}\n")
    string(APPEND args_content "ZIP_FILE\n${CUSTOM_BINARY_PATH}\n")
    string(APPEND args_content "ZIP_NAME\n${CUSTOM_ZIP_NAME}\n")
    string(APPEND args_content "ZIP_TARGET\n${target_list}\n")
    string(APPEND args_content "ZIP_PARAM\n${CUSTOM_ZIP_NAME}image_index=${CUSTOM_ZIP_SLOT_ID}\n")
    string(APPEND args_content "---\n")
    
    file(APPEND "${dfu_args_file}" "${args_content}")

    message(STATUS "DFU: Added extra binary ID ${CUSTOM_BINARY_ID} -> ${CUSTOM_BINARY_PATH} (ZIP: ${CUSTOM_ZIP_NAME})")
endfunction()

#
# Get all extra binary information for use in multi-image packaging
#
# This function is used internally by the packaging system to retrieve
# all registered extra binaries.
#
function(dfu_multi_image_get_extra out_ids out_paths out_targets)
    # Initialize lists
    set(extra_ids)
    set(extra_paths)
    set(extra_targets)
    
    # Load from args file if it exists
    set(dfu_args_file "${CMAKE_BINARY_DIR}/dfu_extra_binaries.args")
    if(EXISTS "${dfu_args_file}")
        file(READ "${dfu_args_file}" args_content)
        string(REPLACE "\n" ";" args_lines "${args_content}")
        
        set(reading_mode "")
        foreach(line ${args_lines})
            if(line STREQUAL "MULTI_IMAGE_ID")
                set(reading_mode "ID")
            elseif(line STREQUAL "MULTI_IMAGE_PATH")
                set(reading_mode "PATH")
            elseif(line STREQUAL "MULTI_IMAGE_TARGET")
                set(reading_mode "TARGET")
            elseif(line STREQUAL "ZIP_FILE" OR line STREQUAL "ZIP_NAME" OR line STREQUAL "ZIP_TARGET" OR line STREQUAL "ZIP_PARAM")
                set(reading_mode "SKIP")  # Skip ZIP-related sections
            elseif(line STREQUAL "---")
                set(reading_mode "")
            elseif(NOT line STREQUAL "" AND NOT reading_mode STREQUAL "" AND NOT reading_mode STREQUAL "SKIP")
                if(reading_mode STREQUAL "ID")
                    list(APPEND extra_ids "${line}")
                elseif(reading_mode STREQUAL "PATH")
                    list(APPEND extra_paths "${line}")
                elseif(reading_mode STREQUAL "TARGET")
                    list(APPEND extra_targets "${line}")
                endif()
            endif()
        endforeach()
        
        list(LENGTH extra_ids count)
        if(count GREATER 0)
            message(STATUS "DFU: Found ${count} extra binaries for multi-image package")
        endif()
    endif()

    set(${out_ids} "${extra_ids}" PARENT_SCOPE)
    set(${out_paths} "${extra_paths}" PARENT_SCOPE)
    set(${out_targets} "${extra_targets}" PARENT_SCOPE)
endfunction()

#
# Get all extra binary information for use in ZIP packaging
#
# This function is used internally by the ZIP packaging system to retrieve
# all registered extra binaries.
#
function(dfu_zip_get_extra out_bin_files out_zip_names out_targets out_script_params)
    # Initialize lists
    set(extra_bin_files)
    set(extra_zip_names)
    set(extra_targets)
    set(extra_script_params)
    
    # Load from args file if it exists
    set(dfu_args_file "${CMAKE_BINARY_DIR}/dfu_extra_binaries.args")
    if(EXISTS "${dfu_args_file}")
        file(READ "${dfu_args_file}" args_content)
        string(REPLACE "\n" ";" args_lines "${args_content}")
        
        set(reading_mode "")
        foreach(line ${args_lines})
            if(line STREQUAL "ZIP_FILE")
                set(reading_mode "FILE")
            elseif(line STREQUAL "ZIP_NAME")
                set(reading_mode "NAME")
            elseif(line STREQUAL "ZIP_TARGET")
                set(reading_mode "TARGET")
            elseif(line STREQUAL "ZIP_PARAM")
                set(reading_mode "PARAM")
            elseif(line STREQUAL "---")
                set(reading_mode "")
            elseif(NOT line STREQUAL "" AND NOT reading_mode STREQUAL "")
                if(reading_mode STREQUAL "FILE")
                    list(APPEND extra_bin_files "${line}")
                elseif(reading_mode STREQUAL "NAME")
                    list(APPEND extra_zip_names "${line}")
                elseif(reading_mode STREQUAL "TARGET")
                    list(APPEND extra_targets "${line}")
                elseif(reading_mode STREQUAL "PARAM")
                    list(APPEND extra_script_params "${line}")
                endif()
            endif()
        endforeach()
        
        list(LENGTH extra_bin_files count)
        if(count GREATER 0)
            message(STATUS "DFU: Found ${count} extra binaries for ZIP package")
        endif()
    endif()

    set(${out_bin_files} "${extra_bin_files}" PARENT_SCOPE)
    set(${out_zip_names} "${extra_zip_names}" PARENT_SCOPE)
    set(${out_targets} "${extra_targets}" PARENT_SCOPE)
    set(${out_script_params} "${extra_script_params}" PARENT_SCOPE)
endfunction()


